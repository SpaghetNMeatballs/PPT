# Пример правильного оформления лабораторной работы на языке Python 3.*

Для начала создадим основной скрипт `main.py`

Как вы все уже знаете, данная лабораторная работа состоит из 4 заданий, разберём каждое из них отдельно.

## Что нужно знать перед дальнейшим чтением (функции, тайпинг, уговоренности по наименованию)

В данном примере, как и в большинстве скриптов на пайтоне, активно используются функции.  
Что такое функция вы уже должны были выучить за год программирования на Си, здесь же будет просто описан процесс написания функции на пайтоне :^)  
Для обозначения функции в пайтоне используется кейворд `def`, пример:
```
def test_func(a: int = 0, b: int = 0) -> int:
    c = a + b
    return c
```
В коде выше произошло много нового, странного и непонятного, давайте всё разберём по порядку  
Функция `test_func` в данном примере получает на вход два целочисленных значения, вычисляет внутри их сумму и возвращает её через метод `return`  
Даже если функция войдовая (ничего не возвращает), всё равно будет хорошей практикой прописать в конце `return` без параметра после неё чтобы указать завершение выполнения функции  
Также в этой функции прописан тайпинг входных и выходных значений. В рантайме (выполнении программы) этот тайпинг абсолютно никак не участвует - например, в test_func можно передать две строки и получить на выходе результат их конкатенации. Тайпинг нужен только для удобочитаемости кода и проверки кода линтером - так как PyCharm обладает встроенным линтером, вы получите warning если попытаетесь использовать test_func для конкатенации.  
Также вся лабораторная работа оформлена по стандарту PEP-8, с которым рекомендуется ознакомиться каждому начинающему питонисту - никакого CamelCase'а, все функции строчными буквами, переменные названы просто и понятно.
## Задание 1

### Даны две переменные im и re, содержащие произвольные значения типа int. Провести над ними несколько арифметических операций: сложение, вычитание, умножение, остаток от деления и целая часть от деления. Каждый результат преобразовать в тип float. Создать комплексное число формата re+j*im

Простое задание, для выполнения которого напишем функцию `task1` без входных и выходных значений, в которой с помощью метода `print()` выведем в консоль результаты вычислений  
Функция, реализованная для выполнения этого задания, не обладает никакими нюансами, которые хотелось бы обсудить.

## Задание 2

### Даны четыре строки: " i like pizza ", " hot summer", "i often watch serials ", " happy new 2018 year! ". Преобразовать эти строки: привести их к нижнему и верхнему регистру; привести начальные буквы каждого слова в строках к верхнему регистру; привести к верхнему регистру первую букву первого слова в строке; удалить конечные пробелы, а далее удалить начальные; если длина строки меньше заданного параметра, то справа от строки добавить пробелы; если длина строки меньше заданного параметра, то слева от строки добавить пробелы.

Данное задание реализовано в `task2`. В нём нужно было просто повызывать строковые методы для массива, состоящего каких-то строк, из того что вроде бы ещё не проходили - цикл `for` по итерируемому объекту (`list`, `tuple` и т.д.) позволяет перебрать все значения в объекте без необходимости обращаться по индексу.
```
for element in iter_obj:
    # Здесь можно обращаться к element
```

## Задание 3
### Задайте произвольную строковую переменную s. Соберите из неё в новую строковую переменную, используя срезы строки (результаты для строки «Революция!» приведены ниже в скобках). Срезы строки без изменений должны работать для любых строк, а не только для тестовой (за исключением случаев, когда индексы указаны явно)!
### Вариант 1 - 4 первых и 4 последних символа

Здесь уже что-то интересное. Для слайсов реализуем функцию `task3`, которая на вход будет принимать строку, и в качестве аргумента по умолчанию поставим строку "Революция!". Вовзращать будем полученную строку после слайсов. После написания преобразований строки может показаться, что всё сделано верно, но как в этом убедиться? Напишем юнит-тест. Юнит-тест - это тест, используемый для проверки отдельного небольшого участка кода. В данном случае проверим, что наша функция действительно возвращает первые и последние 4 символа.

Для этого воспользуемся библиотекой для тестирования `pytest`. Чтобы её установить, можно воспользоваться настройками вашей среды программирования или просто написать в терминале `pip install -r requirements.txt` (при условии что вы локально клонировали этот проект, в ином случае - ctrl+alt+s и настройки интерпретатора).

Теперь создадим скрипт `test_example.py`, в котором будем хранить наши тесты для этого проекта. Забегая вперёд, в данной лабораторной третье задание - единственное, к которому можно применить подход тестирования, но при оформлении любого задания, где у вас есть чёткие примеры на вход и выход рекомендуется перенести эти примеры в вид тестов и по возможности дописать свои - это поможет как проверить верность исполнения задачи, так и лучше разобраться в задаче.  
В скрипте создадим функцию `test_task3` без входных переменных, и в ней с использованием выражения `assert`, которое вызывает `Exception` при ложности логического выражения, проверим равенство результата работы нашей функции и ожидаемого результата.  
Для исполнения тестов напишем в консоли `pytest` - после этого фреймворк для тестирования соберёт все файлы с началом `test_*` из текущей директории и запустит в них функции с началом `test_*`.

## Задание 4
### Отформатируйте число 12 таким образом, чтобы программа выдала строку для его двоичного, восьмеричного и шестнадцатиричного представления как: "bin: 1100, oct: 14, hex: c".  
Реализуем функцию `task4`, в которую на вход будет поступать целое число (по умолчанию 12) и в процессе исполнения будет форматироваться в соответствии с заданием обоими способами.

## Последующее оформление
Далее создадим функцию `main`, в которой по очереди будут вызываться все задания с обозначением вызова каждой.  
После проверки на исполнение `if __name__ == '__main__'` будем вызывать эту функцию.  
**Зачем нужна проверка на исполнение?** Проверка на исполнение по своей сути в подобного рода лабораторных не требуется, но это очень полезная привычка, которую лучше развить у себя раньше, чем потом переучиваться. Лабораторные за редким исключением состоят из 1-2 файлов, в то время как серьёзные Python проекты состоят из десятков скриптов. В процессе импорта одного скрипта в другой импортируемый скрипт исполняется целиком, за исключением кода под этой проверкой. Таким образом, если какие-то сложные вычисления/многократные принты/пользовательский ввод не поставлены в эту проверку, а "висят снаружи" - это может в лучшем случае замедлить работу программы, в худшем вызывать исключения.  
## Итог
Таким образом, конечная программа состоит из 4 функций - по одной на задание, `main`-функции, в которой вызываются необходимые в данный момент задания, проверки на исполнение и отдельного скрипта с тестами. Надеюсь, этот пример поможет вам с оформлением ваших работ и заинтересует вас в улучшении своих навыков написания кода.